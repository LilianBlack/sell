封装时   接到一个参数是引用数据类型时候，default值要写函数返回一个对象/数组    ()=>( return {} )   或者 ()=>( {} )   或者()=>[]

可能多地使用的   封装在components文件夹里


管理系统不考虑响应式


封装主页小卡片
二次封装账号页面的面板
表单组件
账号 商品


表单的自定义验证
    form表单处
        validator函数
        使用方式 ：
        rules:{
            acc:{validator:myfun, trigger:'blur'}
            // 下面是必填
            acc:{require:true,  validator:自定义函数名, trigger:'blur'}
        }
    在data(){}中return{}前面  ----  定义函数myfun 
     --------- 【 const myfun(rule, val, callback)=>{} 】
    myfun这个自定义验证函数 自动传入三个值   myfun形参是：rule\val\callback
    验证通过----直接调用callback函数
    验证不通过-----要给callback传一个参数 参数是 new Error('相对的错误提示')


    同一个项目各个位置的正则应统一 因此正则不写死，用变量
    工具函数utils--> reg.js    项目中通用正则
            const ACC_REG =
            const PWD_REG =
        使用：  在使用的vue文件引入   import {ACC_REG，  PWD_REG} from '@/utils/reg.js'


    一致性验证：【确认密码】
        做完非空验证后
        验证 本输入的值是否等于上一个输入的值
        小bug----在填好确认密码后 再修改新密码的值    不会触发一致性验证
        ---解决：反向触发【在输入新密码的验证函数中验证一次一致性】
                如果确认新密码输入框不为空，则使用表单的函数validateField
                  this.$refs.对应的表单的ref值.validateField('要验证的部分字段名')进行一致性验证
                  注意：  不是给输入的值  是给这个字段的名字



面包屑
    计算面包屑函数----一进入页面就调用函数、侦听器观察地址栏变化，变化了就调用函数




    在index.js中----对有二级菜单的一级菜单栏重定向到自己的第一个子地址
    index.js  --->  配置 meta:{title:'订单管理}




    后台数据库名是 sell    所以创建的数据库必须叫sell





改数据库密码
7-11   day 03
    调试接口
    大企业---接口分层管理  不会直接发请求，调用工具函数即可发送请求
    工具函数层---> ajax函数接口层  ---> 分模块封装ajax函数

    同时下载axios qs     命令：yarn add axios qs 或者 npm i axios qs
    在工具函数中引入axios和qs  import ....

    拼接地址    

    请求拦截的 config、相应拦截的response是对象

    启动服务器   后台先安装依赖
    解构【回车发送】


    token========请求的权限问题401
    token的作用：接口鉴权
        先请求登录接口【不需要权限】---响应数据有个令牌--token
        后面请求时都带上token【放请求头】===在请求拦截函数中从本地取出token，给config的属性header对象添加属性Authorization【不能写成其他的】和属性值
        得到token的时候，将它存入本地


    暴露的时候使用的是 export default{}  则引入的时候不加{}
    如果暴露出来的时候没有使用export default{}【暴露一个对象】,引用的时候要加{},如reg.js的引用

    postman测试的时候
    先登录， 得到的token 不复制Barea  复制随机代码放在authorasition的ba...里


    响应拦截器----根据响应code弹窗，后续的各处请求操作可以不再写弹窗
    对 response.data先进行存在性判断，再解构
    响应的 code 和  msg 默认值是undefined
    ElementUI 提供了一个消息弹窗 单独引入   
     vue文件中this指向的是实例对象，.js文件中的this被vue重置为undefined
     单独引入的 Message === this.$msg


     能够统一处理的---都在响应拦截器中处理


     ctime 的处理 
        下载yarn moment  
        引入moment
        循环数组--处理时间ctime
    分页
    删除  
    批量删除


    data中占位的数据一般是用于渲染的

    不渲染但是想全局的  可以挂在this上，， 如 let this.ids


    给后台发数组  需要 JSON.stringify  
    保证后台收到字符串

    删除的小bug
        当最后一页的数据删除完了以后，不会自动跳转  而是显示   暂无数据 留在本页
        优化： 在获取数据的函数中进行 边界判断
                还有，当已经是第一页的时候，不能再将页码减一了
                if( !data.length && page != 1 )

        如果用户没有选择的时候就点击批量删除，会导致发送一个无效的请求

    dropdown 组件自带事件 command
        选中下拉框中的元素时，元素绑定的command的值会自动传入command事件触发的函数内部
    token可以设置失效时间？



    横向滚动条问题：  把table的长度计算出来
     computed{
         width: document.body.clientWidth - 侧边栏的宽度  +'px'
     } 



7-13
    


    7-14
    form 有个属性   :inline='true   可将表单内部元素变成一行   ========OK
    el-form-column   有属性 fixed  写上就表示定位固定
    日期时间选择器 组件 自带的属性  value-format 可以设置日期格式
        如 value-format ="yyyy-MM-dd  HH:mm:ss"
    日期时间选择器 小bug     当清空参数后  选择器会把时间初始化为null
    这时候查询就会出错  因为传的时间是null   所以要在发送时间的时候要进行处理
    
    加一个重置按钮【增强用户体验】 ========OK


    商品列表加一个查询   搜索框  下拉框  搜索按钮 重置按钮 ==========OK

    点击编辑   跳转页面             ==========  OK  不是弹出蒙层  是跳转页面  
    
     还要解决激活导航的问题==========OK

    获取参数的方式：  路由传参【 传递id进行一次查询】    本地存储  
        路由传参  对象方式   传递数据 query 方式是地址栏传递【在编辑商品的传参   字段太长 不适用路由传参  用本地/会话更合适】
        路由传参 不能传递对象 要传递字符串   可以 JSON.stringify    最好只传送id

    路由传参----params方式携带数据-----好处：地址栏没有携带数据  且可以传递整个对象
        通过路由名字进行跳转【路由配置中需要配置name】
        bug：  刷新则数据清空
        解决： 进入页面就把 数据先放本地
        用处：  移动端【移动APP没有手动刷新   只有程序猿可以代码刷新嘻嘻嘻嘻】

    最后还是本地存储 和 路由query方式稳定

    店铺管理                ==========  OK  ！！！！！！
    商铺图片的回填！！！！


    写图片的基础路径，  找到图片所在文件， 将文件路径复制到浏览器地址栏，将地址的 public以及其前面所有的地址改为  http://127.0.0.1:5000【端口看情况】
    后面跟上文件夹中的图片名和后缀  即可以正常显示



    商铺信息的上传
    店铺头像上传
    店铺图片上传
    提交修改信息【注意！】
        图片地址处理  substr
        date处理为字符串
        pics处理为 图片名数组  数组再才处理为字符串
        
        列表页的纵向滚动   ==========不  OK  




7-16    封装Echarts
    1、echarts集成进入项目
        准备：下载echarts--->引入echarts --->准备一个有宽高的容器
        使用： 初始化盒子-->  写配置【查文档】---> 使用配置生成报表
            选中节点：  原生的   vue的（$ref  $refs）   jQuery的
        注意： vue使用echarts 需要在mounted中   created获取不到dom节点

    2、使用
        配置【官网教程看】---任何都可配置
        tooltips : 工具提示---鼠标放在图上的提示
        一般折线图   axis    柱状图是item
        legend   图例【可以提供各种图标，还可以使用自定义图片作为图例】
        legend 和 series 对应起来才能显示报表
        grid   绘图网格区域【支持双轴】
        boundaryGap    折线图切换成柱状图的时候， 需要改变boundaryGap的值 
        series可以传入对象--自定义样式

    3、封装图形   每一种风格封装一种   
        风封装复杂，暴露简单

    4、随机bug  ---- 封装组件涉及父传子，父亲会发送ajax时   可能会遇到的【有时能渲染 有时不能】
            打印查看
            是异步导致的问题
        解决1： 在组件内部解决， 加侦听器watch，但是watch不能观察多级对象，需要使用 深度监听
                
        解决1： 用标杆 v-if="flag"---等到数据拿到  再允许创建节点  没有bug
        解决2： 整一个定时器   有bug

vue   封装一个 类似elementUI的模态框组件
父传子传入的值不可以在子中进行改变 单向信息流
要改变这个数据只能是 子传父 通知父去修改值



组件里面再套组件----作用域插槽



动态路由   作用域插槽 面试常问



7-17
    权限分配【扩展性很强：只需要向meta中的role数组添加角色】
        登录存入角色信息
        根据角色信息设置动态路由
        引入 index.js文件可以不写文件名
        默认路由只有两个大入口
        其他路由为动态计算
        meta  可以配置一些自定义的数据   name在其中配置一个role数组，代表可以访问的角色
        不配置role属性则代表所有角色都有权限

    算出动态路由后， 动态挂载路由 router的方法 addRoutes（）
        vue router的bug【router没有删除路由的方法】：退出账户后，【只要不刷新】路由不会初始化，以至于切换账号的时候，下一个账户是上一个的路由
        解决：  一旦退出登录，立即刷新网页    
        退出登录时： location.reload();   //每次退出就刷新一次   解决用户权限不刷新则维持上一个用户权限的问题
        把算出来的路由动态挂载
        router.addRouter(计算出来的路由数组)

    算出导航栏的显示栏目
        根据算出来的权限路由进行计算
        给路由配置 visible  false表示不显示
        函数判断当前路由是否显示，要显示的路由放入数组
        算出的菜单存到本地
        created 阶段获取本地的菜单
    


    渲染菜单
        判断一级菜单有没有子菜单【分为有下拉的和没有下拉的   其中订单管理属于特殊的，有子菜单但是没有显示】
        订单管理  具有子菜单  但是没有下拉框

    配置图标   也用meta来进行配置  使其动态

    step1、
        登录的时候将role存到本地  同时调用index.js中的创建路由的方法【不是登陆成功才调用。照顾到刷新】
    step2、
        新创建一个数组存放所有路由【还有一个是默认的静态路由，存放的是两个主路由，在创建路由对象时挂载的是静态路由】
        在路由中写出权限配置
            给路由配置权限，meta没有配置 role属性的则是所有角色都拥有权限，配置角色以后就只有配置的角色才拥有权限
    step3、
        在index.js文件中实现创建路由的方法 createRoutes
    step4、
        实现一个方法  判断是否有权限 hasPermission
    step5、
        实现一个方法  calcuRoute  计算有权限的路由 递归出每一层
        内置方法   addRoute   动态添加路由 
    step6、
        权限菜单实现【只用做一级】
    step7、
        菜单的激活高亮设置
    step8、
        添加菜单对应的icon
    
注意：   将功能细粒化---一个函数只完成一个小功能   组合调用完成整体功能
        
        在路由文件夹中index.js   分离出固定的路由和需要计算的


   
   
   
   
    打包上线：记得交dist文件给后端！！！  npm run build   /  yarn build  打包
        首先修改所有的ip地址  改为公网ip 【涉及到图片】
        组件化开发   打包上线后生成dist文件  交给后台上线

 




